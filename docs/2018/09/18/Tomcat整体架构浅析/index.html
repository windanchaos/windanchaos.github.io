<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Tomcat整体架构浅析 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Tomcat整体架构浅析</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/me.html"><i class="fa fa-user"> Über</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Tomcat整体架构浅析</h1><div class="post-meta">2018-09-18<span> | </span><span class="category"><a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">后端框架和技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2018/09/18/Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/#vcomment"><span class="valine-comment-count" data-xid="/2018/09/18/Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"></span><span> Comment</span></a><div class="post-content"><p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cx520forever/article/details/52743166">https://blog.csdn.net/cx520forever/article/details/52743166</a><br>tomcat详解搭配着看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/7228274.html">https://www.cnblogs.com/kismetv/p/7228274.html</a></p>
<p>comment：本文基于Tomcat7.0.68</p>
<h1 id="1-整体结构"><a href="#1-整体结构" class="headerlink" title="1.整体结构"></a>1.整体结构</h1><p>架构图：<br><img src="/images/.net-uploads-201206-05-1338887929_7279.JPG.png" alt="这里写图片描述"></p>
<h2 id="1-1各组件解释："><a href="#1-1各组件解释：" class="headerlink" title="1.1各组件解释："></a>1.1各组件解释：</h2><p>从顶层开始：</p>
<p>一般情况下我们并不需要配置多个Service,conf&#x2F;server.xml默认配置了一个“Catalina”的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Service</span>&gt;</span><br></pre></td></tr></table></figure>
<p>。<br><strong>Tomcat将Engine，Host，Context，Wrapper统一抽象成Container。</strong><br>Connector接受到请求后，会将请求交给Container，Container处理完了之后将结果返回给Connector<br>下面看Container的结构：<br><img src="/images/nblogs.com-blog-665375-201601-665375-20160119184849437-2014392220-.png" alt="这里写图片描述"></p>
<p><img src="/images/-upload-picture-pic-124649-3f5d0ac0-1c40-3c78-9bed-e990f41e3b84.jpg.png" alt="这里写图片描述"><br>Standard&#x2F;*XXXX&#x2F;*是组件接口的默认实现类。</p>
<p>Tomcat 还有其它组件，如安全组件 security、logger、session、naming 等其它组件。这些组件共同为 Connector 和 Container 提供必要的服务。</p>
<h2 id="1-2组件的生命线Lifecycle"><a href="#1-2组件的生命线Lifecycle" class="headerlink" title="1.2组件的生命线Lifecycle"></a>1.2组件的生命线Lifecycle</h2><p>Tomcat中很多组件具有生命周期,如初始化、启动、关闭，这些组件的生命周期具有共性，因此Tomcat中将其抽象为接口Lifecycle，来控制组件的生命周期，它通过 <strong>事件机制</strong> 实现各个容器间的内部通讯。<br>Lifecycle接口的方法：<br><img src="/images/dn.net-20161006125439657.png" alt="这里写图片描述"><br>继承关系图：<br><img src="/images/dn.net-20161006124601442.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>StandardServer，StandardService，Connector和上面4个容器等很多组件都实现了Lifecycle，组件实现这个接口就可以统一被拥有它的组件控制了，这样一层一层的直到一个 <strong>最高级的组件</strong> 就可以控制 Tomcat 中所有组件的生命周期，这个最高的组件就是 **</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Server</span></span><br></pre></td></tr></table></figure>
<p>**。</p>
<h1 id="2-启动流程"><a href="#2-启动流程" class="headerlink" title="2.启动流程"></a>2.启动流程</h1><p>在bin目录下执行了.&#x2F;startup.sh 或者执行 .&#x2F;catalina.bat start命令时,实际调用了Bootstrap启动类的main方法，并传递了start参数。<br>Bootstrap&#x2F;#main方法的启动流程：<br>参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/Zerohuan/article/details/50752635#t6">http://blog.csdn.net/Zerohuan/article/details/50752635/#t6</a><br>附上别人总结的一张启动时序图：<br><img src="/images/dn.net-20150327153152547-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzkyOTgzMzYyM2x2Y2hh-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-Center.png" alt="这里写图片描述"><br>补充如下：</p>
<ul>
<li>关于Connector初始化和启动的更多细节，可参考本人另一篇blog <a target="_blank" rel="noopener" href="http://blog.csdn.net/cx520forever/article/details/52198050">http://blog.csdn.net/cx520forever/article/details/52198050</a></li>
</ul>
<h1 id="3-pipeline-valve机制"><a href="#3-pipeline-valve机制" class="headerlink" title="3.pipeline valve机制"></a>3.pipeline valve机制</h1><h2 id="3-1名词解释"><a href="#3-1名词解释" class="headerlink" title="3.1名词解释"></a>3.1名词解释</h2><h2 id="3-2总体分析"><a href="#3-2总体分析" class="headerlink" title="3.2总体分析"></a>3.2总体分析</h2><p>四个基本容器对象里面都有一个pipeline及valve模块，是容器类必须具有的模块，对象生成时set该属性。Pipeline就像是每个容器的逻辑总线。在pipeline上按照配置的顺序，加载各个valve。通过pipeline完成各个valve之间的调用，各个valve实现具体的应用逻辑。<br>tomcat组件图：<br><img src="/images/dn.net-20161006212818345.png" alt="tomcat组件图"><br>从上图中看到，在Connector接收到一次连接并转化成HttpServletRequest请求对象后，<strong>请求传递如下</strong>：<br>Connector–&gt;Engine的Pipeline的ValveA中–&gt;Engine Valve–&gt;Host Pipeline的Error Report Valve和Host Value–&gt;Context Valve–&gt;Wrapper Valve中，在这里会经过一个过滤器链（Filter Chain）–&gt;Servlet中。<br>Servlet处理完成后一步步返回，最后Connector拿到response。</p>
<h2 id="3-3接口及默认实现"><a href="#3-3接口及默认实现" class="headerlink" title="3.3接口及默认实现"></a>3.3接口及默认实现</h2><p>接口中定义的方法:<br><img src="/images/dn.net-20161007001421097.png" alt="接口中定义的方法"><br>一个pipeline包含多个Valve，这些阀共分为两类，一类叫基础阀（通过getBasic、setBasic方法调用），一类是普通阀（通过addValve、removeValve调用）。管道都是包含在容器中，所以有getContainer和setContainer方法。一个管道一般有一个基础阀（通过setBasic添加），可以有0到多个普通阀（通过addValve添加）。<br>isAsyncSupported：当管道中的所有阀门都支持异步时返回ture，否则返回false<br>该接口的标准实现是：**</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.<span class="property">apache</span>.<span class="property">catalina</span>.<span class="property">core</span>.<span class="property">StandardPipeline</span></span><br></pre></td></tr></table></figure>
<p>**<br>Engine、Host、Context及Wrapper的pipeline属性都继承自父类ContainerBase。</p>
<p>接口方法:<br><img src="/images/dn.net-20161007002724932.png" alt="这里写图片描述"><br>重点关注setNext、getNext、invoke这三个方法，通过setNext设置该阀的下一阀，通过getNext返回该阀的下一个阀的引用，invoke方法则执行该阀内部自定义的请求处理代码。<br>ValveBase：是Valve接口的基本实现<br>四大容器类r都有各自缺省的标准valve实现。它们分别是</p>
<p><img src="/images/dn.net-20161007003208809.png" alt="这里写图片描述"></p>
<p>Valve实现了具体业务逻辑单元。可以定制化valve（实现特定接口），然后配置在server.xml里。每层容器都可以配置相应的valve，当只在其作用域内有效。例如engine容器里的valve只对其包含的所有host里的应用有效。<br>配置举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Engine</span> name=<span class="string">&quot;Catalina&quot;</span> defaultHost=<span class="string">&quot;localhost&quot;</span>&gt;  </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;MyValve0&quot;</span>/&gt;</span></span>  </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;MyValve1&quot;</span>/&gt;</span></span>  </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;MyValve2&quot;</span>/&gt;</span></span>  </span><br><span class="line">   ……  </span><br><span class="line">  &lt;<span class="title class_">Host</span> name=<span class="string">&quot;localhost&quot;</span>  appBase=<span class="string">&quot;webapps&quot;</span>&gt;  </span><br><span class="line">  &lt;/<span class="title class_">Host</span>&gt;  </span><br><span class="line">&lt;/<span class="title class_">Engine</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当在server.xml文件中配置了一个定制化valve时，会调用pipeline对象的addValve方法，将valve以链表方式组织起来，代码如下;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">addValve</span>(<span class="params">Valve valve</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate that we can add this Valve</span></span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> <span class="title class_">Contained</span>)</span><br><span class="line">            ((<span class="title class_">Contained</span>) valve).<span class="title function_">setContainer</span>(<span class="variable language_">this</span>.<span class="property">container</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the new component if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">getState</span>().<span class="title function_">isAvailable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> <span class="title class_">Lifecycle</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((<span class="title class_">Lifecycle</span>) valve).<span class="title function_">start</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="title class_">LifecycleException</span> e) &#123;</span><br><span class="line">                    log.<span class="title function_">error</span>(<span class="string">&quot;StandardPipeline.addValve: start: &quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add this Valve to the set associated with this Pipeline</span></span><br><span class="line">        <span class="comment">//将配置的valve添加到链表中，并且每个容器的标准valve在链表的尾端 </span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = valve;</span><br><span class="line">            valve.<span class="title function_">setNext</span>(basic);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title class_">Valve</span> current = first;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.<span class="title function_">getNext</span>() == basic) &#123;</span><br><span class="line">                    current.<span class="title function_">setNext</span>(valve);</span><br><span class="line">                    valve.<span class="title function_">setNext</span>(basic);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current.<span class="title function_">getNext</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        container.<span class="title function_">fireContainerEvent</span>(<span class="title class_">Container</span>.<span class="property">ADD_VALVE_EVENT</span>, valve);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>valve按照容器作用域的配置顺序来组织valve，每个valve都设置了指向下一个valve的next引用。同时，每个容器缺省的标准valve都存在于valve链表尾端，最后被调用。<br>Pipeline内部维护first和basic两个阀，其它相关阀通过getNext来获取。</p>
<p><strong>标准valve的调用逻辑图：</strong><br><img src="/images/dn.net-20161007004829253.png" alt="这里写图片描述"><br>从StandardEngineValve开始， **所有的基础阀的实现最后都会调用其下一级容器，所有的普通阀都会执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getNext</span>().<span class="title function_">invoke</span>(request, response);</span><br></pre></td></tr></table></figure>
<p>**，一直到StandardWrapperValve，完成请求处理过程。因为Wrapper是对一个Servlet的包装，所以它的基础阀内部调用的过滤器链的doFilter方法和Servlet的service方法。<br>上述机制保证了请求传递到servlet去处理。</p>
<p>当采用tomcat默认初始配置时，Valve链如下：<br><img src="/images/dn.net-20161007005430411.png" alt="这里写图片描述"><br>这些阀门Valve通过invoke方法彼此串联起来，最终构成的执行顺序十分类似于一个管道。</p>
<h1 id="4-Tomcat中的设计模式"><a href="#4-Tomcat中的设计模式" class="headerlink" title="4.Tomcat中的设计模式"></a>4.Tomcat中的设计模式</h1><h2 id="4-1模板方法模式"><a href="#4-1模板方法模式" class="headerlink" title="4.1模板方法模式"></a>4.1模板方法模式</h2><p><strong>把通用的骨架步骤抽象到父类中，子类去实现特定的某些步骤。</strong><br>举例：<br>如LifecycleBase类中init和start方法，其中的nitInternal和startInternal方法是抽象方法，所有容易都直接或间接继承了LifecycleBase，在初始化和启动时被每个容器会调用其init和start方法，这些抽象方法都是在子类中实现的。</p>
<h2 id="4-2责任链模式"><a href="#4-2责任链模式" class="headerlink" title="4.2责任链模式"></a>4.2责任链模式</h2><h2 id="4-3观察者模式"><a href="#4-3观察者模式" class="headerlink" title="4.3观察者模式"></a>4.3观察者模式</h2><p>Tomcat通过LifecycleListener对组件生命周期组件Lifecycle进行监听，各个组件在其生命期中会有各种行为，而这些行为都会触发相应的事件，Tomcat就是通过侦听这些事件达到对这些行为进行扩展的目的。在看组件的init和start过程中会看到大量如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fireLifecycleEvent</span>(<span class="variable constant_">CONFIGURE_START_EVENT</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这样的代码，这就是对某一类型事件的触发，如果你想在其中加入自己的行为，就只用注册相应类型的事件即可。</p>
</div><div class="tags"><a href="/tags/FromCSDN"><i class="fa fa-tag">FromCSDN</i></a></div><div class="post-nav"><a class="pre" href="/2018/09/29/crontab%20%E5%9C%A8GUI%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%A7%E8%A1%8Cwebdriver/">crontab 在GUI环境下执行webdriver</a><a class="next" href="/2018/09/10/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E3%80%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E6%95%B0%E3%80%81%E5%AD%97/">【计算机理论基础】二进制与数、字</a></div><div id="vcomment"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'0indNw0niJU8jN2a1E43bDW7-gzGzoHsz',
  appKey:'toErPcjDI3431WvXQVKoy0rC',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://windanchaos.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="Über"><img src="/images/avatar.jpeg"/></a><p>物有本末，事有终始。知所先后，则近道矣！</p><a class="info-icon" href="https://blog.csdn.net/windanchaos" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:454522630@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/windanchaos" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://gitee.com/windanchaos" title="Gitee" target="_blank" style="margin-inline:5px"> <i class="fa fa-gitee-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">Java编程语言</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/">Linux管理维护</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">MySQL数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">python编程语言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">前端框架和技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">后端框架和技术</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%B9%E6%B3%95%E4%B8%8E%E7%AE%A1%E7%90%86/">方法与管理</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">测试的框架和技术</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E5%A4%A7%E6%9D%82%E7%83%A9/">生活大杂烩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">股票量化交易</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/">计算机科学基础</a><span class="category-list-count">10</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/FromCSDN/" style="font-size: 15px;">FromCSDN</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/JDK%E4%B8%ADJUC%E5%8C%85%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94atomic%E5%8C%85/">JDK中JUC包由浅入深原理——atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/22/ELF%E5%AD%A6%E4%B9%A0%E4%B8%80/">ELF学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/07/SpringBoot%E4%B9%8B%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%88%98/">SpringBoot之博客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/17/shell%E4%B8%89%E5%89%91%E5%AE%A2%E5%AE%9E%E6%88%98/">shell三剑客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/mybatis%E5%85%A5%E4%B8%AA%E9%97%A8/">mybatis入个门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/SpringBoot%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/">SpringBoot入门系列一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/">Java多线程编程核心技术读书笔记二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/">Java多线程编程核心技术读书笔记一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Spring%E6%A1%86%E6%9E%B6%E5%85%A5%E4%B8%AA%E9%97%A8/">Spring框架入个门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">java动态代理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>