<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Supervisor源码研究和学习 | windanchaos</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Supervisor源码研究和学习</h1><a id="logo" href="/.">windanchaos</a><p class="description">知行合一</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/me.html"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Supervisor源码研究和学习</h1><div class="post-meta">2019-11-26<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/">计算机科学基础</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/26/Supervisor%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E5%92%8C%E5%AD%A6%E4%B9%A0%E4%B8%80/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/26/Supervisor%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E5%92%8C%E5%AD%A6%E4%B9%A0%E4%B8%80/"></span><span> 条评论</span></a><div class="post-content"><h1 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h1><p>最近，在构思一套内部环境服务的监控系统，起码的功能是能识别到业务进程异常（进程级别的），退出后自动拉起。<br>找到了supervisor，了解基本功能后，觉得它在分布式方面还存在不足之处，所有配置分散在单机上。鉴于它的技术符合目前需要练习python技术栈。所以，准备对其源代码进行解构、分析和学习。</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>源码研究和学习，起码要对该工具如何使用有个基本的掌握。</p>
<p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork&#x2F;exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="medusa"><a href="#medusa" class="headerlink" title="medusa"></a>medusa</h2><p>它依赖第三方的<a target="_blank" rel="noopener" href="http://www.nightmare.com/medusa/">medusa</a>来处理网络请求。medusa的源码也值得学习和研究。</p>
<h2 id="supervisord"><a href="#supervisord" class="headerlink" title="supervisord"></a>supervisord</h2><p>类似于docker所在服务器运行的守护进程，负责响应客户端的命令行、受监控进程的监控、重启、受控子进程的标准输入输出的日志、生成和处理与子流程生命周期中相对应的“事件”。配置文件一般为&#x2F;etc&#x2F;supervisord.conf。</p>
<h2 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="supervisorctl"></a>supervisorctl</h2><p>控制台，和supervisord交互。通过控制台，用户可以连接到不同的supervisord进程（ 通过UNIX domain socket or an internet (TCP) socket），查看supervisord的控制进程的状态。读取&#x2F;etc&#x2F;supervisord.conf下的[supervisorctl]内容作为配置。</p>
<h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><p>supervisord的浏览器控制台。仅支持单机模式，就是说，N台服务器安装了supervisor的话，就有N个webServer，它们彼此之间并没有关联，所以也没有一个集中化的界面统一管理。</p>
<p>有个php的解决方案：<a target="_blank" rel="noopener" href="https://blog.csdn.net/geerniya/article/details/80107761">https://blog.csdn.net/geerniya/article/details/80107761</a></p>
<h2 id="XML-RPC-Interface"><a href="#XML-RPC-Interface" class="headerlink" title="XML-RPC Interface"></a>XML-RPC Interface</h2><p>The same HTTP server which serves the web UI serves up an XML-RPC interface that can be used to interrogate and control supervisor and the programs it runs.</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>优点：<br>    - 可以将非后台运行程序后台运行<br>    - 自动监控，重启进程</p>
<p>缺点：<br>    - 不能管理后台运行程序<br>    - 对多进程服务，不能使用kill关闭</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>源码分析步骤：</p>
<p>1、clone代码到本地；</p>
<p>2、本地做supervisord的配置</p>
<p>3、参考别写的源码文章，找到程序入口，阅读代码</p>
<p>4、debug若干次，追中代码运行逻辑</p>
<span id="more"></span>

<h2 id="执行逻辑和核心"><a href="#执行逻辑和核心" class="headerlink" title="执行逻辑和核心"></a>执行逻辑和核心</h2><p>supervisord作为进程入口，启动后先将自己的进程daemon化。接着开始利用opitons.py中的代码，对配置进行初始化，读取关键配置，我目前只研究了启动监控进程部分。读取完配置后，去检查运行环境、进程状态等，没有启动则启动受控进程，受控进程和supervisor的进程通过pipes通信，子进程状态上报。其中的核心方法只有一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># options.py中的方法</span><br><span class="line">    def execve(self, filename, argv, env):</span><br><span class="line">        return os.execve(filename, argv, env)</span><br></pre></td></tr></table></figure>
<p>其他代码都服务于它，supervisor的进程控制模块的代码基本就围绕这如何构建filename,argv,env这三大参数展开。如何展开的我就不细说了，debug运行跟，基本都暴露给出来了。要提醒以下的是，执行os.execve这个方法，是supervisor的进程先fork了子进程后再跑的os.execve。</p>
<h2 id="supervisor自身的数据模型"><a href="#supervisor自身的数据模型" class="headerlink" title="supervisor自身的数据模型"></a>supervisor自身的数据模型</h2><p>当然这个主要内容都在supervisor&#x2F;supervisor&#x2F;supervisord.py里了。</p>
<p>我试着做个简单解读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Supervisor:</span><br><span class="line">    # 下面4个是进程自身的状态控制信息</span><br><span class="line">    # 处理发送了停止请求的参数</span><br><span class="line">    stopping = False # set after we detect that we are handling a stop request</span><br><span class="line">    # 暂时不清楚这个参数具体干什么</span><br><span class="line">    lastshutdownreport = 0 # throttle for delayed process error reports at stop</span><br><span class="line">    # &#123;进程组名称:进程组&#125;的map信息</span><br><span class="line">    process_groups = None # map of process group name to process group object</span><br><span class="line">    # 按优先级排序了的被shutdown了的进程组信息的list</span><br><span class="line">    stop_groups = None # list used for priority ordered shutdown</span><br><span class="line"></span><br><span class="line">    def __init__(self, options):</span><br><span class="line">        self.options = options #配置信息</span><br><span class="line">        self.process_groups = &#123;&#125; #hold住的进程组</span><br><span class="line">        self.ticks = &#123;&#125; #消息机制</span><br></pre></td></tr></table></figure>
<p>这里需要注意，supervisor对受控进程进行管理，采用的进程组的概念，而不是单进程。</p>
<p>supervisord.py里有个逻辑很漂亮，那就是把自己daemon化了。具体代码怎么流转的自己看代码了，只写我觉得对我有价值的内容。</p>
<h3 id="实现daemon进程的套路"><a href="#实现daemon进程的套路" class="headerlink" title="实现daemon进程的套路"></a>实现daemon进程的套路</h3><p>supervisor启动时，也是被自己的父进程fork出来的。因此，它遵循了daemon化的一般原则，详见下面方法的说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># supervisor的run方法中有一句，进程状态还不是daemon并且是第一加载配置就daemon化</span><br><span class="line">        if (not self.options.nodaemon) and self.options.first:</span><br><span class="line">            self.options.daemonize()</span><br></pre></td></tr></table></figure>
<p>调用os.setsid,让进程摆脱父进程的session（会话）而自立门户，成为新的进程组的leader。而有一种情况是自身本来就是会话的leader的化就没有办法再自立门户了，所以标准动作是先fork自己，退出自己，再把fork出来的进程。options中的daemon方法，满满的套路。代码作者还给出了为什么要把标准0.1.2设置为null的原因。<a target="_blank" rel="noopener" href="http://www.hawklord.uklinux.net/system/daemons/d3.htm">点击跳转自己读</a>，如果用我大白话说的话，意思很简单，linux下一切。老实说，我觉得damonize这个方法应该放到进程的相关模块中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def daemonize(self):</span><br><span class="line">    # To disassociate ourselves from our parent&#x27;s session group we use</span><br><span class="line">    # os.setsid.  It means &quot;set session id&quot;, which has the effect of</span><br><span class="line">    # disassociating a process from is current session and process group</span><br><span class="line">    # and setting itself up as a new session leader.</span><br><span class="line">    #</span><br><span class="line">    # Unfortunately we cannot call setsid if we&#x27;re already a session group</span><br><span class="line">    # leader, so we use &quot;fork&quot; to make a copy of ourselves that is</span><br><span class="line">    # guaranteed to not be a session group leader.</span><br><span class="line">    #</span><br><span class="line">    # We also change directories, set stderr and stdout to null, and</span><br><span class="line">    # change our umask.</span><br><span class="line">    #</span><br><span class="line">    # This explanation was (gratefully) garnered from</span><br><span class="line">    # http://www.hawklord.uklinux.net/system/daemons/d3.htm</span><br><span class="line"></span><br><span class="line">    pid = os.fork()</span><br><span class="line">    if pid != 0:</span><br><span class="line">        # Parent</span><br><span class="line">        self.logger.blather(&quot;supervisord forked; parent exiting&quot;)</span><br><span class="line">        os._exit(0)</span><br><span class="line">    # Child</span><br><span class="line">    self.logger.info(&quot;daemonizing the supervisord process&quot;)</span><br><span class="line">    if self.directory:</span><br><span class="line">        try:</span><br><span class="line">            os.chdir(self.directory)</span><br><span class="line">        except OSError, err:</span><br><span class="line">            self.logger.critical(&quot;can&#x27;t chdir into %r: %s&quot;</span><br><span class="line">                                 % (self.directory, err))</span><br><span class="line">        else:</span><br><span class="line">            self.logger.info(&quot;set current directory: %r&quot;</span><br><span class="line">                             % self.directory)</span><br><span class="line">    os.close(0)</span><br><span class="line">    self.stdin = sys.stdin = sys.__stdin__ = open(&quot;/dev/null&quot;)</span><br><span class="line">    os.close(1)</span><br><span class="line">    self.stdout = sys.stdout = sys.__stdout__ = open(&quot;/dev/null&quot;, &quot;w&quot;)</span><br><span class="line">    os.close(2)</span><br><span class="line">    self.stderr = sys.stderr = sys.__stderr__ = open(&quot;/dev/null&quot;, &quot;w&quot;)</span><br><span class="line">    os.setsid()</span><br><span class="line">    os.umask(self.umask)</span><br><span class="line">    # XXX Stevens, in his Advanced Unix book, section 13.3 (page</span><br><span class="line">    # 417) recommends calling umask(0) and closing unused</span><br><span class="line">    # file descriptors.  In his Network Programming book, he</span><br><span class="line">    # additionally recommends ignoring SIGHUP and forking again</span><br><span class="line">    # after the setsid() call, for obscure SVR4 reasons.</span><br></pre></td></tr></table></figure>
<p>所以，python的daemon进程的一般套路可以总结为：</p>
<ul>
<li>fork子进程，fork有两个返回值，通过返回值执行逻辑</li>
<li>返回值为不为0，就是父进程，退出父进程</li>
<li>子进程执行os.setid()，让自己成为进程组和会话的leader。</li>
<li>安全的关闭父进程的三标（输入、输出、错误）</li>
<li>重新指定子进程的标三标，使用os.dup或os.dup2函数，supervisor直接赋值。</li>
<li>重新设置子进程的掩码umask，就是chmod给权限的时候那组组合数字，出于安全性的考虑，往往不希望这些文件被别的用户查看。这时，可以使用umask函数修改文件权限，创建掩码的取值，以满足守护进程的要求。</li>
<li>重新指定子进程的工作目录。当进程没有结束时，其工作目录是不能被卸载的。为了防止这种问题发生，守护进程一般会将其工作目录更改到根目录下（&#x2F;目录）。更改工作目录使用的函数是chdir。</li>
</ul>
<p>需要注意：</p>
<p> 在 Unix 上通过 spawn 和 forkserver 方式启动多进程会同时启动一个 资源追踪 进程，负责追踪当前程序的进程产生的、并且不再被使用的命名系统资源(如命名信号量以及 SharedMemory 对象)。当所有进程退出后，资源追踪会负责释放这些仍被追踪的的对象。通常情况下是不会有这种对象的，但是假如一个子进程被某个信号杀死，就可能存在这一类资源的“泄露”情况。（泄露的信号量以及共享内存不会被释放，直到下一次系统重启，对于这两类资源来说，这是一个比较大的问题，因为操作系统允许的命名信号量的数量是有限的，而共享内存也会占据主内存的一片空间）。要选择一个启动方法，你应该在主模块的 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘ 子句中调用 set_start_method()</p>
<p>supervisord模块就解读完毕。</p>
<h2 id="supervisor的配置模型"><a href="#supervisor的配置模型" class="headerlink" title="supervisor的配置模型"></a>supervisor的配置模型</h2><p>都在options.py中了，基类Options。</p>
<p>从配置中，我们可以窥探出supervisor整个系统由哪些元素构成。这里做一个列举，它们的基类是Options：</p>
<ul>
<li>ServerOptions</li>
<li>ClientOptions</li>
<li>ProcessConfig</li>
<li>ProcessGroupConfig</li>
<li>EventListenerConfig</li>
<li>EventListenerPoolConfig</li>
<li>FastCGIGroupConfig</li>
<li>FastCGIProcessConfig</li>
</ul>
<p>这里要吐槽下，我现在对python的模块原则还不了解，所以我对supervisor作者在options.py写了些异常类表示不理解，按linux一个命令只做一件事这种原则，不是应该有个异常类的模块才对？</p>
<p>配置从哪里来，我大致看了：命令行、默认配置路径找。</p>
<p>如果我要写和配置有关的代码，我会再来细究，这里就跳过了。</p>
<h2 id="supervisor受控进程模型"><a href="#supervisor受控进程模型" class="headerlink" title="supervisor受控进程模型"></a>supervisor受控进程模型</h2><p>process.py中，Subprocess是最重要的一个类。基本几大类：状态、日志、事件、管道、异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Subprocess:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;A class to manage a subprocess.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # Initial state; overridden by instance variables</span><br><span class="line"></span><br><span class="line">    pid = 0 # Subprocess pid; 0 when not running</span><br><span class="line">    config = None # ProcessConfig instance</span><br><span class="line">    state = None # process state code</span><br><span class="line">    listener_state = None # listener state code (if we&#x27;re an event listener)</span><br><span class="line">    event = None # event currently being processed (if we&#x27;re an event listener)</span><br><span class="line">    laststart = 0 # Last time the subprocess was started; 0 if never</span><br><span class="line">    laststop = 0  # Last time the subprocess was stopped; 0 if never</span><br><span class="line">    delay = 0 # If nonzero, delay starting or killing until this time</span><br><span class="line">    administrative_stop = 0 # true if the process has been stopped by an admin</span><br><span class="line">    system_stop = 0 # true if the process has been stopped by the system</span><br><span class="line">    killing = 0 # flag determining whether we are trying to kill this proc</span><br><span class="line">    backoff = 0 # backoff counter (to startretries)</span><br><span class="line">    dispatchers = None # asnycore output dispatchers (keyed by fd)</span><br><span class="line">    pipes = None # map of channel name to file descriptor #</span><br><span class="line">    exitstatus = None # status attached to dead process by finsh()</span><br><span class="line">    spawnerr = None # error message attached by spawn() if any</span><br><span class="line">    group = None # ProcessGroup instance if process is in the group</span><br><span class="line"></span><br><span class="line">    def __init__(self, config):</span><br><span class="line">        &quot;&quot;&quot;Constructor.</span><br><span class="line"></span><br><span class="line">        Argument is a ProcessConfig instance.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.config = config</span><br><span class="line">        self.dispatchers = &#123;&#125;</span><br><span class="line">        self.pipes = &#123;&#125;</span><br><span class="line">        self.state = ProcessStates.STOPPED</span><br></pre></td></tr></table></figure>
<h3 id="进程状态模型"><a href="#进程状态模型" class="headerlink" title="进程状态模型"></a>进程状态模型</h3><p>ProcessStates类中，该类在state.py中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ProcessStates:</span><br><span class="line">    STOPPED = 0</span><br><span class="line">    STARTING = 10</span><br><span class="line">    RUNNING = 20</span><br><span class="line">    BACKOFF = 30</span><br><span class="line">    STOPPING = 40</span><br><span class="line">    EXITED = 100</span><br><span class="line">    FATAL = 200</span><br><span class="line">    UNKNOWN = 1000</span><br><span class="line"></span><br><span class="line">STOPPED_STATES = (ProcessStates.STOPPED,</span><br><span class="line">                  ProcessStates.EXITED,</span><br><span class="line">                  ProcessStates.FATAL,</span><br><span class="line">                  ProcessStates.UNKNOWN)</span><br><span class="line"></span><br><span class="line">RUNNING_STATES = (ProcessStates.RUNNING,</span><br><span class="line">                  ProcessStates.BACKOFF,</span><br><span class="line">                  ProcessStates.STARTING)</span><br></pre></td></tr></table></figure>



<p>那接下来，在开源代码中学习代码及所属领域的知识是研究的出发点。</p>
<h1 id="我的应用场景"><a href="#我的应用场景" class="headerlink" title="我的应用场景"></a>我的应用场景</h1><p>supervisor并不适合我的应用场景。</p>
<p>首先，它是作为父进程来fork受监控的进程的，也就是子进程的生命周期它能无微不至的照顾到，虽然子进程的所有信息它都能掌握，但在我的场景下，有发版和更新的刚性需求。如果用supervisor来监控和拉起，就导致发版更新后也不得不用supervisor的自动重启来完成。这种强耦合的方式并不是很优美，会导致大量改造工作。</p>
<p>其次，部署信息都是散落在服务器上的，对于超过10个应用，甚至更多，分散化的部署维护起来也不方便。所以有个潜在的需求，统一配置受控进程。supervisor的http服务是单机版的，对于分布式部署来说，缺少一个统一界面维护。</p>
<p>所以，我可能会supervisor做如下的改造：</p>
<ul>
<li>获取监控进程的信息源来自db或者redis之类持久化的存储服务</li>
<li>fork子进程，但是并不监控子进程的状态，只判定它是否存在。不存在超过一个阈值自动拉起。</li>
<li>有一个受控进程的展现页面，所有被supervisor分散监控进程状态都列在上面，可以触发重启、启动操作</li>
</ul>
<p>源码解读第一波就到这了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="http://www.supervisord.org/">supervisor官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33339479/article/details/78374837">supervisoer源码分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xybz1993/article/details/80869471">进程组、session、前台任务、后台任务、守护进程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edisonchou/p/5003694.html">操作系统核心原理-3.进程原理（上）：进程概要</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014688145/article/details/50644876">进程实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22613757/article/details/88770579">fork()子进程与父进程的关系（继承了什么）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gangstudyit/article/details/80551912">操作系统中信号工作原理</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cems.uwe.ac.uk/~irjohnso/coursenotes/lrc/system/daemons/d3.htm">supervisor的daenon进程原理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/diantong/p/10413079.html">linux的文件描述符</a></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/12/20/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92%E7%BA%B2%E8%A6%81/">中小型网站的容量规划纲要</a><a class="next" href="/2019/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86/">操作系统进程原理</a></div><div id="vcomment"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'0indNw0niJU8jN2a1E43bDW7-gzGzoHsz',
  appKey:'toErPcjDI3431WvXQVKoy0rC',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://windanchaos.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/images/avatar.jpeg"/></a><p>物有本末，事有终始。知所先后，则近道矣！</p><a class="info-icon" href="https://blog.csdn.net/windanchaos" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:454522630@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/windanchaos" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://gitee.com/windanchaos" title="Gitee" target="_blank" style="margin-inline:5px"> <i class="fa fa-gitee-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">Java编程语言</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/">Linux管理维护</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">MySQL数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">python编程语言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">前端框架和技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">后端框架和技术</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%B9%E6%B3%95%E4%B8%8E%E7%AE%A1%E7%90%86/">方法与管理</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">测试的框架和技术</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E5%A4%A7%E6%9D%82%E7%83%A9/">生活大杂烩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">股票量化交易</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/">计算机科学基础</a><span class="category-list-count">10</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/FromCSDN/" style="font-size: 15px;">FromCSDN</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/JDK%E4%B8%ADJUC%E5%8C%85%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94atomic%E5%8C%85/">JDK中JUC包由浅入深原理——atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/22/ELF%E5%AD%A6%E4%B9%A0%E4%B8%80/">ELF学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/07/SpringBoot%E4%B9%8B%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%88%98/">SpringBoot之博客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/17/shell%E4%B8%89%E5%89%91%E5%AE%A2%E5%AE%9E%E6%88%98/">shell三剑客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/mybatis%E5%85%A5%E4%B8%AA%E9%97%A8/">mybatis入个门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/SpringBoot%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/">SpringBoot入门系列一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/">Java多线程编程核心技术读书笔记二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/">Java多线程编程核心技术读书笔记一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Spring%E6%A1%86%E6%9E%B6%E5%85%A5%E4%B8%AA%E9%97%A8/">Spring框架入个门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">java动态代理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">windanchaos.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>