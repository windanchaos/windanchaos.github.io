<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>windanchaos | 知行合一</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">windanchaos</h1><a id="logo" href="/.">windanchaos</a><p class="description">知行合一</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/me.html"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2017/06/12/Shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93/">Shell字符串处理规律总结</a></h1><div class="post-meta">2017-06-12</div><div class="post-content">字符处理几个特殊约定&#x2F;#代表截掉开始
12345chaosbom@chaosbomPC:~$ file=&quot;thisfile.txt&quot;chaosbom@chaosbomPC:~$ echo $&#123;file#*.&#125;txtchaosbom@chaosbomPC:~$ echo $&#123;file#*i&#125;...</div><p class="readmore"><a href="/2017/06/12/Shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/05/19/Appium%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Appium的基本概念</a></h1><div class="post-meta">2017-05-19</div><div class="post-content"><h1 id="一、appium是什么？"><a href="#一、appium是什么？" class="headerlink" title="一、appium是什么？"></a>一、appium是什么？</h1><p>Appium 是一个自动化测试开源、跨平台工具。它允许测试人员在不同的平台（iOS，Android）使用同一套API来写自动化测试脚本，这样大大增加了 iOS 和 Android 测试套件间代码的复用性。支持 iOS 平台和 Android 平台上的原生应用，web 应用和混合应用。<br>所谓的“移动原生应用”是指那些用 iOS 或者 Android SDK 写的应用。<br>所谓的“移动 web 应用”是指使用移动浏览器访问的应用（Appium 支持 iOS 上的 Safari 和 Android 上的 Chrome）。<br>所谓的“混合应用”是指原生代码封装网页视图——原生代码和 web 内容交互。比如，像 Phonegap，可以帮助开发者使用网页技术开发应用，然后用原生代码封装，这些就是混合应用。</p>
<h1 id="二、Appium的基本原理"><a href="#二、Appium的基本原理" class="headerlink" title="二、Appium的基本原理"></a>二、Appium的基本原理</h1><h2 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h2><p>Appium 真正的工作引擎是第三方自动化框架。使用以下的第三方框架：<br><strong>- iOS: 苹果的 UIAutomation</strong><br><strong>- Android 4.2+: Google’s UiAutomator</strong></p>
<ul>
<li>Android 2.3+: Google’s Instrumentation. (Instrumentation由单独的项目Selendroid提供支持 )</li>
<li>Selenium WebDriver等第三方包，<a target="_blank" rel="noopener" href="https://search.maven.org/remotecontent?filepath=io/appium/java-client/5.0.0-BETA8/java-client-5.0.0-BETA8.pom">点此参考java依赖包</a></li>
</ul>
<h2 id="C-x2F-S-架构"><a href="#C-x2F-S-架构" class="headerlink" title="C&#x2F;S 架构"></a>C&#x2F;S 架构</h2><p>Appium使用客户端-服务端的架构，它 的核心是一个 web 服务器，它提供了一套 REST 的接口， 指定了客户端到服务端的协议。 (JSON Wire Protocol)。<br>我们可以使用任何语言来编写客户端，向服务端发送恰当的 HTTP 请求。它收到客户端的连接，监听到命令，接着在移动设备上执行这些命令，然后将执行结果放在 HTTP响应中返还给客户端。事实上，这种客户端&#x2F;服务端的架构给予了许多的可能性：比如我们可以使用任何实现了该客户端的语言来写我们的测试代码。比如我们可以把服务端放在不同 的机器上。比如我们可以只写测试代码，然后使用像 Sauce Labs 这样的云服务来解释命令。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>自动化始终围绕一个session进行，客户端初始化一个seesion（会话）来与服务端交互，不同的语言有不同的实现方式，但是他们最终都是发送为一个POST请求给服务端，请求中包含一个JSON对象，被称作“desired capabilities”。此时，服务端就会开启一个自动化的 session，然后返回一个 session ID，session ID将会被用户发送后续的命令。</p>
<h2 id="Desired-Capabilities"><a href="#Desired-Capabilities" class="headerlink" title="Desired Capabilities"></a>Desired Capabilities</h2><p>Desired capabilities 是一些键值对的集合 (比如，一个 map 或者 hash），客户端将这些键值对发给服务端，告诉服务端我们想要怎么测试。比如，我们可以把platformName capability 设置为 iOS，告诉 Appium 服务端，我们想要一个iOS 的 session，而不是一个 Android 的。我们也可以设置 safariAllowPopups capability 为 true，确保在 Safari 自动化 session 中，我们可以使用 javascript 来打开新窗口。参见 capabilities 文档，查看完整的 capabilities 列表。</p>
<h2 id="Appium-Server"><a href="#Appium-Server" class="headerlink" title="Appium Server"></a>Appium Server</h2><p>Appium server 是用 Node.js 写的。我们可以用源码编译或者从 NPM 直接安装。</p>
<h2 id="Appium客户端"><a href="#Appium客户端" class="headerlink" title="Appium客户端"></a>Appium客户端</h2><p>Appium 客户端端有很多语言库 Java, Ruby, Python, PHP, JavaScript 和 C&#x2F;#，这些库都实现了 Appium 对 WebDriver 协议的扩展。当使用 Appium 的时候，你只需使用这些库代替常规的 WebDriver 库就可以了。 你可以从<a target="_blank" rel="noopener" href="http://appium.io/slate/cn/master/#appium-clients.cn.md">这里</a>看到所有的库的列表。</p></div><p class="readmore"><a href="/2017/05/19/Appium%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/05/06/%E5%9F%BA%E4%BA%8Egit%20maven%20jenkins%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%E4%B8%89/">基于git maven jenkins的自动构建发布系统三</a></h1><div class="post-meta">2017-05-06</div><div class="post-content"><p>本人使用Linux的shell脚本对公司测试及生产代码的自动构建发布进行了开发工作，并实际运用到工作当中，显著提高了代码发布的效率，减少了人工发版出错的概率。但是，公司迭代速度非常快，开发进度十分聊得，敏捷的模式下，研发提交代码，再到发布到测试环境的频率很高，由于我负责维护和使用这套东西，在解决bug的过程中，个人的生产力大部分被发版占据。痛定思痛，本人打算将shell脚本升级到更加自动化的程度，解放我的生产力。这便引入了jenkins，强大的自动构建部署服务。<br>安装过程此处略过。<br>使用了jenkins的open blue ocean，学习了很久如何在pipline中使用groovy的脚本，并研读了官网教程，没有办法的是，所预想的脚本始终run不成功，基本都是语法错误,而且对于jenkinsFiles的语法，除了看到别人写的知道什么意思外，基本达成不了自己预期的。所以，退而其次，我把所有的功能都写到了shell脚本里，只借助jenkins去执行就好了。<br>参考jenkins的构建流程，shell脚本分为：</p>
<p>使用jenkins新建了如下job:<br><img src="/images/dn.net-20170506175834112-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2luZGFuY2hhb3M=-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png" alt="这里写图片描述"></p>
<p>其中，pull code的job每一个小时拉取代码一次，自动引发自动编译job（build auto），但不发布。也就是代码是自动拉取并编译的。</p>
<p>pull code 的pipline script:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">   def mvnHome</span><br><span class="line">   <span class="title function_">stage</span>(<span class="params"><span class="string">&#x27;Preparation&#x27;</span></span>) &#123; <span class="comment">// for display purposes</span></span><br><span class="line">      <span class="comment">// Get some code from a Git repository</span></span><br><span class="line">      sh <span class="string">&quot;~/ci/pull.sh&quot;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pull.sh内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">githome=<span class="string">&quot;/home/admin/gitCode/&quot;</span></span><br><span class="line">#设置环境变量</span><br><span class="line">source /etc/profile</span><br><span class="line">cd $&#123;githome&#125;</span><br><span class="line">#git reset --hard <span class="variable constant_">HEAD</span>^</span><br><span class="line">echo <span class="string">&quot;git分支名称：&quot;</span>+<span class="string">`git status |awk &#x27;&#123;print $4&#125;&#x27; |head -1`</span></span><br><span class="line">echo <span class="string">&quot;拉取当前分支代码&quot;</span></span><br><span class="line">git pull origin <span class="string">`git status |awk &#x27;&#123;print $4&#125;&#x27;|head -1`</span></span><br></pre></td></tr></table></figure>

<p>build auto 的pipline script:</p></div><p class="readmore"><a href="/2017/05/06/%E5%9F%BA%E4%BA%8Egit%20maven%20jenkins%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%E4%B8%89/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/25/%E6%88%91%E8%BF%99%E4%B8%80%E5%B9%B4%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%86%B5/">我这一年的技术学习概况</a></h1><div class="post-meta">2017-04-25</div><div class="post-content">2016年上半年５月之前，准备中级软考，主考软件设计师，最后没有考过。考证的主要出发点是恶补下计算机基础，能过最好过不了也可以接受。开始写技术日志是从２０１６年的７月，那段时间在学习java代码，曾尝试阅读公司商城的源代码，代码大而全，确实切入困难，尝试过了解spring的架构之类的，最后还是没有达到看源码的水平。用java写了个自动登录系统投票的小软件给未...</div><p class="readmore"><a href="/2017/04/25/%E6%88%91%E8%BF%99%E4%B8%80%E5%B9%B4%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%86%B5/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/18/eclipse%20class%20file%20editor%20source%20not%20found/">eclipse class file editor source not found</a></h1><div class="post-meta">2017-04-18</div><div class="post-content">使用maven构建的依赖库，selenium 要查看源代码，提示source not found。主要是因为maven下依赖库的时候，没有下载源代码，class无法解析出来。直接右击项目，选择run as —》 maven Build，在Goals中输入：dependency:sources然后就自动下载库对应的源代码~~完美解决！
</div><p class="readmore"><a href="/2017/04/18/eclipse%20class%20file%20editor%20source%20not%20found/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/17/Selenium%20Webdriver%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E4%BE%8B/">Selenium Webdriver重新使用已打开的浏览器实例</a></h1><div class="post-meta">2017-04-17</div><div class="post-content"><p>本文转自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51232302">http://blog.csdn.net/wwwqjpcom/article/details/51232302</a><br>本文中的样例均使用SoapUI ，关于SoapUI+Webdriver 的配置，请看上一篇：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51174664"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51174664">http://blog.csdn.net/wwwqjpcom/article/details/51174664</a></p>
<p>我弄这个的本意是为了在SoapUI中更好地编写自动化用例，因为我的业务流程有的很长，有7-8个页面。<br>我想把代码不集中在一个Groovy 脚本里，想在第二个脚本中继续使用第一个脚本中打开的浏览器。这样便于<br>维护和定位问题。<br>也还有一种情况是我打开了浏览器，，操作了系统到某一个界面后，我写了这个页面的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>脚本，使用已<br>打开的浏览器我立刻就可以单独对这个页面进行测试，测试我写的代码是否OK 。不通过就人工操作复位页面，<br>修改代码后再次测试，不用每次测试代码是否可行都从头打卡浏览器，登录系统，重新操作了。可以实现分步<br>单页面调试自动化脚本。</p>
<p>首先，来简单看一下Selenium Webdriver如何工作的。<br>（1）Selenium代码调用API实际上根据 The WebDriver Wire Protocol 发送不同的Http Request 到 WebdriverServer。<br>IE 是 IEDriverServer.exe<br>Chrome是ChromerDriver，下载地址： <a target="_blank" rel="noopener" href="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a><br>Firefox是以插件的形式，直接在selenium-server-standalone-XXX.jar里了：<br>webdriver.xpi （selenium-server-standalone-2.48.2.jar中&#x2F;org&#x2F;openqa&#x2F;selenium&#x2F;firefox&#x2F;目录下）</p>
<p>new FirefoxDriver()时，启动Firefox浏览器时，带此插件一起启动，然后插件会默认监听7055端口，7055被占用就使用下一个端口。如下图所示。<br><img src="/images/dn.net-20160424100800878.png" alt="这里写图片描述"><br>同一台机器上可以同时启动多个FirefoxDriver实例，每个实例占用不同的端口号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">The</span> <span class="title class_">WebDriver</span> <span class="title class_">Wire</span> <span class="title class_">Protocol</span> 协议的具体内容请看：<span class="attr">https</span>:<span class="comment">//code.google.com/p/selenium/wiki/JsonWireProtocol#Introduction。  这个协议现在正在被W3C标准化，W3C Webdriver，两者基本一样。  </span></span><br><span class="line"><span class="variable constant_">W3C</span> <span class="title class_">Webdriver</span>标准协议内容：<span class="attr">http</span>:<span class="comment">//www.w3.org/TR/webdriver/</span></span><br></pre></td></tr></table></figure>

<p>（2）WebdriverServer接收到Http Request之后，根据不同的命令在<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/operatingsystem" title="操作系统知识库">操作系统</a>层面去触发浏览器的”native事件“，<br>模拟操作浏览器。WebdriverServer将操作结果Http Response返回给代码调用的客户端。</p>
<p>为了更清晰直观地看到这个是如何运转的，我们来在使用OWASP ZAP做代理，截获Http Request和Response来看一下。<br>首先安装OWASP ZAP或其他有代理功能的工具，设置SoapUI Proxy，如ZAP默认使用8080端口，则SoapUI配置如下：<br><img src="/images/dn.net-20160424100954806.png" alt="这里写图片描述"><br>配置完SoapUI端口后，好像需要重启SoapUI，然后在SoapUI 的自动化测试代码中，代理才能正常工作。</p>
<p>重新跑前一节FirefoxDriver的代码，查看截获的请求和响应。如下图所示：<br><img src="/images/dn.net-20160424101223635.png" alt="这里写图片描述"></p></div><p class="readmore"><a href="/2017/04/17/Selenium%20Webdriver%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E4%BE%8B/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/17/Appium%20%E5%BE%AE%E4%BF%A1%20webview%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/">Appium 微信 webview 的自动化技术</a></h1><div class="post-meta">2017-04-17</div><div class="post-content">目录 
1&lt;blockquote&gt;

最近好多人问微信webview自动化的事情, 碰巧我也在追微信webview的自动化和性能分析方法.先发出来一点我的进展给大家参考下. 此方法用于android平台, iOS请自行解决
微信的设置用微信打开debugx5.qq.com, 这是个微信的x5内核调试页面. 你可以在任何聊天窗口内输入这个网址. 并...</div><p class="readmore"><a href="/2017/04/17/Appium%20%E5%BE%AE%E4%BF%A1%20webview%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/13/Selenium%202.0%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">Selenium 2.0的由来及设计架构</a></h1><div class="post-meta">2017-04-13</div><div class="post-content"><p>本文转自：blog.csdn.net&#x2F;zzzmmmkkk&#x2F;article&#x2F;details&#x2F;10034213</p>
<p><strong>布局和<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javascript" title="JavaScript知识库">JavaScript</a></strong></p>
<p>浏览器自动化工具基本上由三部分构成：</p>
<p>·与DOM交互的方法</p>
<p>·执行Javascript的机制</p>
<p>·一些模拟用户输入的办法</p>
<p>本节重点介绍第一部分：提供与DOM交互的机制。浏览器的办法是通过Javascript，所以看起来与DOM交互的理想语言也是它。虽然这种选择似乎显而易见，但是在考虑Javascript时需要平衡一些有趣的挑战和需求。</p>
<p>像多数大型项目一样，Selenium使用了分层的库结构。底层是Google的Closure库，提供原语和模块化机制来协助源文件保持精简。在此之上，有一个实用工具库，提供的函数包括简单的任务，如获取某个属性值、判断某个元素是否对用户可见，还包括更加复杂的操作，如通过合成事件模拟用户点击。在项目中，这些被视为提供最小单元的浏览器自动化，因此称之为浏览器自动化原子（Browser Automation Atom）。最后，还有适配层来组合这些原子单元以满足WebDriver和Core的API协议。</p>
<p><img src="/images/dn.net-20130817205048703-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenp6bW1ta2tr-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<p>图 3：Selenium Javascript库的层次结构</p>
<p>选择Closure库基于几种原因。主要理由是Closure编译器理解库使用的模块化技术。Closure编译器的目标是输出Javascript。“编译”可以简单到按照依赖顺序查找输入文件、串联并漂亮的打印出来，也可能复杂到进行精细的改动和删除死代码。另一种不可否认的优势是团队中采用Javascript编程的几位成员对Closure库非常熟悉。</p>
<p>当需要与DOM交互时，“原子”库的代码会被用于项目中的各个角落。对于RC和那些大部分由Javascript编写而成的driver来说，这些库被直接使用，通常编译为单个巨大的脚本。对于采用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase" title="Java SE知识库">Java</a>编写的driver，来自WebDriver适配层的各个函数在编译的时候会启用完整优化，生成的Javascript在JAR中作为资源包含进来。对于采用C语言编写的driver，如iPhone IE驱动，不仅各个函数被通过完整优化来编译，而且生成的输出文件被转换成定义在头文件中的常量，通过driver的正常Javascript执行机制来执行。虽然这看起来有些奇怪，但是这种做法使Javascript放在底层驱动中，无须在各处暴露原始的代码。</p>
<p>因为原子库应用广泛，所以在不同浏览器之间确保一致的行为是可行的，因为库采用Javascript编写，而且无需提升权限来执行开发周期，所以方便、快捷。Closure库可以动态加载依赖，因此Selenium开发人员只需编写<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>并在浏览器中加载，修改代码并在需要时点击刷新按钮。一旦测试在浏览器中通过，很容易在另一个浏览器中加载并确保通过。因为Closure库在抽象屏蔽浏览器之间的差异方面做得很好，这就足够在持续构建中在每一种支持的浏览器中运行测试集以衡量是否通过。</p>
<p>最初Core和WebDriver存在许多相同的代码——通过略微不同的方式执行相同的功能。当我们开始关注原子库时，这些代码被重新梳理，我们努力找出最合适的功能。毕竟，两个项目都被广泛应用，它们的代码非常健壮，因此把一切都丢掉从零开始不仅浪费而且愚蠢。通过对每个原子库的分析，我们找出了可以使用的部分。例如，Firefox driver的getAttribute方法从大约50行缩减到几行，包括空白行在内：</p>
<p>FirefoxDriver.prototype.getElementAttribute &#x3D;function(respond, parameters) {var element &#x3D; Utils.getElementAt(parameters.id, respond.session.getDocument());var attributeName &#x3D; parameters.name;respond.value &#x3D; webdriver.element.getAttribute(element, attributeName);respond.send();};</p>
<p>倒数第二行中，respond.value的赋值调用了原子级的WebDriver库。</p>
<p>原子库是本项目若干<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/architecture" title="大型网站架构知识库">架构</a>思想的实际演示。当然，它们满足了API的实现应该倾向于Javascript的需求。更出色的是，用一个库在代码库中分享，以前一个缺陷需要在多种实现中验证和修复，现在只需在一个地方修改即可，这种做法降低了变化的成本，同时提高了稳定性和有效性。原子库也使项目的“巴士”因素更优化。因为通常的Javascript单元测试可以用于验证缺陷是否修复，所以参与到开源项目中的障碍要比之前需要了解每一个driver如何实现的时候更低。</p>
<p>使用原子库还有另外一个好处。模拟现有RC实现但由WebDriver支持的分层对团队尝试以可控的方式迁移到更新的WebDriver API是一种重要的工具。因为Selenium Core是原子化的，所以单独编译每一个函数是可行的，使得编写这种模拟层易于实现而且更准确。</p>
<p>当然，这种做法也存在缺点。最重要的是，把Javascript编译成C常量是一种非常奇怪的事情，它总是阻碍那些想参与C语言编程的项目贡献者。而且很少有开发人员能够了解所有浏览器并致力于每一种浏览器上运行所有测试——很可能有人会不小心在某处引入回归问题，我们需要花时间找到问题，如果持续构建很多的话则更需精力。</p></div><p class="readmore"><a href="/2017/04/13/Selenium%202.0%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/13/Selenium%201.0%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Selenium 1.0的历史及工作原理</a></h1><div class="post-meta">2017-04-13</div><div class="post-content"><p>本文引至：<a target="_blank" rel="noopener" href="http://blog.csdn.net/zzzmmmkkk/article/details/9274781">http://blog.csdn.net/zzzmmmkkk/article/details/9274781</a></p>
<p>当你看到这篇文章时一定会诧异，2.0都广泛使用了，为何还要了解1.0的内容呢？1.0的确已经慢慢的成为历史，那我们就先通过历史来认识一下selenium的发展吧。</p>
<p>Jason Huggins在2004年发起了Selenium项目，当时他在ThoughtWorks公司开发内部的时间和费用（Time and Expenses）系统，该应用使用了大量的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javascript" title="JavaScript知识库">JavaScript</a>。虽然IE在当时是主流浏览器，但是ThoughtWorks还使用一些其他浏览器（特别是Mozilla系列），当员工在自己的浏览器中无法正常运行T&amp;E系统时就会提交bug。当时的开源工具要么关注单一浏览器（通常是IE），要么是模拟浏览器（如HttpUnit），而购买商业工具授权的成本会耗尽这个小型内部项目的有限预算，所以它们都不太可行。</p>
<p>幸运的是，所有被<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>的浏览器都支持Javascript。Jason和他所在的团队有理由采用Javascript编写一种测试工具来验证应用的行为。他们受到FIT(Framework for Integrated Test）的启发，使用基于表格的语法替代了原始的Javascript，这种做法支持那些编程经验有限的人在HTML文件中使用关键字驱动的方式来编写测试。该工具，最初称为“Selenium”，后来称为“Selenium Core”，在2004年基于Apache 2授权发布。</p>
<p>Selenium的表格格式类似于FIT的ActionFixture。表格的每一行分为三列。第一列给出了要执行的命令名称，第二列通常包含元素标记符，第三列包含一个可选值。例如，如下格式表示了如何在名称为“q”的元素中输入字符串“Selenium”：</p>
<p>type name&#x3D;q Selenium</p>
<p>因为Selenium过去使用纯JavaScript编写，它的最初设计要求开发人员把准备测试的应用和Selenium Core、测试脚本部署到同一台服务器上以避免触犯浏览器的安全规则和JavaScript沙箱策略。在实际开发中，这种要求并不总是可行。更糟的是，虽然开发人员的IDE能够帮助他们快速处理代码和浏览庞大的代码库，但是没有针对HTML的相关工具。人们很快意识到维护一个中等规模的测试集是笨拙而痛苦的过程。</p>
<p>为了解决这个问题和其他问题，他们编写了HTTP代理，这样所有的HTTP请求都会被Selenium截获。使用代理可以绕过“同源”规则（浏览器不支持Javascript调用任何当前页面所在服务器以外的其他任何东西）的许多限制，从而缓解了首要弱点。这种设计使得采用多种语言编写Selenium成为可能：它们只需把HTTP请求发送到特定URL。连接方法基于Selenium Core的表格语法严格建模，称之为“Selenese”。因为语言绑定在远程控制浏览器，所以该工具称为“Selenium Remote Control”或者“Selenium RC”。</p>
<p>就在Selenium处于开发阶段的同时，另一款浏览</p>
<p>器自动化框架WebDriver也正在ThoughtWorks公司的酝酿之中。Selenium2.0之webdriver的介绍请期待下一篇文章。</p>
<p>上面介绍中其实也提到了1.0的概况，下图就是它的流程。</p>
<p><img src="/images/dn.net-20140227220501421-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenp6bW1ta2tr-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<ol>
<li><p>测试用例通过Http请求建立与 selenium-RC server 的连接</p>
</li>
<li><p>Selenium RC Server 驱动一个浏览器，把Selenium Core加载入浏览器页面当中，并把浏览器的代理设置为Selenium Server的Http Proxy</p>
</li>
<li><p>执行用例向Selenium Server发送Http请求，Selenium Server对请求进行解析，然后通过Http Proxy发送JS命令通知Selenium Core执行操作浏览器的动作并注入 JS 代码</p>
</li>
</ol>
<p>4.Selenium Core执行接受到的指令并操作</p>
<ol start="5">
<li><p>当浏览器收到新的请求时，发送http请求</p>
</li>
<li><p>Selenium Server接收到浏览器发送的Http请求后，自己重组Http请求，获取对应的页面</p>
</li>
<li><p>Selenium Server中的Http Proxy把接受到的页面返回给浏览器。</p></div><p class="readmore"><a href="/2017/04/13/Selenium%201.0%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/09/python%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/">python爬取百度图片</a></h1><div class="post-meta">2017-04-09</div><div class="post-content">爬虫的原理：读取页面html元素，解析出目标的url，进入或下载保存。一开始想从百度搜索的结果页面中爬点图片当素材，看了几个前辈写的，很多思路。比如：http://blog.csdn.net/seanwang_25&#x2F;article&#x2F;details&#x2F;43318907
最终实验，目前百度图片搜索列表的元素识别我没有搞定，最后的思路还...</div><p class="readmore"><a href="/2017/04/09/python%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://windanchaos.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/images/avatar.jpeg"/></a><p>物有本末，事有终始。知所先后，则近道矣！</p><a class="info-icon" href="https://blog.csdn.net/windanchaos" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:454522630@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/windanchaos" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://gitee.com/windanchaos" title="Gitee" target="_blank" style="margin-inline:5px"> <i class="fa fa-gitee-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">Java编程语言</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/">Linux管理维护</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">MySQL数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">python编程语言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">前端框架和技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">后端框架和技术</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%B9%E6%B3%95%E4%B8%8E%E7%AE%A1%E7%90%86/">方法与管理</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">测试的框架和技术</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E5%A4%A7%E6%9D%82%E7%83%A9/">生活大杂烩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">股票量化交易</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/">计算机科学基础</a><span class="category-list-count">11</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/FromCSDN/" style="font-size: 15px;">FromCSDN</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a> <a href="/tags/testerhome/" style="font-size: 15px;">testerhome</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E5%B1%82%E6%AC%A1%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6/">计算机各层次执行速度</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/JDK%E4%B8%ADJUC%E5%8C%85%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94atomic%E5%8C%85/">JDK中JUC包由浅入深原理——atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/22/ELF%E5%AD%A6%E4%B9%A0%E4%B8%80/">ELF学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/07/SpringBoot%E4%B9%8B%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%88%98/">SpringBoot之博客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/17/shell%E4%B8%89%E5%89%91%E5%AE%A2%E5%AE%9E%E6%88%98/">shell三剑客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/mybatis%E5%85%A5%E4%B8%AA%E9%97%A8/">mybatis入个门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/SpringBoot%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/">SpringBoot入门系列一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/">Java多线程编程核心技术读书笔记二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/">Java多线程编程核心技术读书笔记一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Spring%E6%A1%86%E6%9E%B6%E5%85%A5%E4%B8%AA%E9%97%A8/">Spring框架入个门</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">windanchaos.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>