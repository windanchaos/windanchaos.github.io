<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>windanchaos | 正文图片请使用非Chrome无跨域限制的浏览器</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">windanchaos</h1><a id="logo" href="/.">windanchaos</a><p class="description">正文图片请使用非Chrome无跨域限制的浏览器</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/me.html"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2017/04/17/Selenium%20Webdriver%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E4%BE%8B/">Selenium Webdriver重新使用已打开的浏览器实例</a></h1><div class="post-meta">2017-04-17</div><div class="post-content"><p>本文转自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51232302">http://blog.csdn.net/wwwqjpcom/article/details/51232302</a><br>本文中的样例均使用SoapUI ，关于SoapUI+Webdriver 的配置，请看上一篇：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51174664"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/wwwqjpcom/article/details/51174664">http://blog.csdn.net/wwwqjpcom/article/details/51174664</a></p>
<p>我弄这个的本意是为了在SoapUI中更好地编写自动化用例，因为我的业务流程有的很长，有7-8个页面。<br>我想把代码不集中在一个Groovy 脚本里，想在第二个脚本中继续使用第一个脚本中打开的浏览器。这样便于<br>维护和定位问题。<br>也还有一种情况是我打开了浏览器，，操作了系统到某一个界面后，我写了这个页面的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>脚本，使用已<br>打开的浏览器我立刻就可以单独对这个页面进行测试，测试我写的代码是否OK 。不通过就人工操作复位页面，<br>修改代码后再次测试，不用每次测试代码是否可行都从头打卡浏览器，登录系统，重新操作了。可以实现分步<br>单页面调试自动化脚本。</p>
<p>首先，来简单看一下Selenium Webdriver如何工作的。<br>（1）Selenium代码调用API实际上根据 The WebDriver Wire Protocol 发送不同的Http Request 到 WebdriverServer。<br>IE 是 IEDriverServer.exe<br>Chrome是ChromerDriver，下载地址： <a target="_blank" rel="noopener" href="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a><br>Firefox是以插件的形式，直接在selenium-server-standalone-XXX.jar里了：<br>webdriver.xpi （selenium-server-standalone-2.48.2.jar中&#x2F;org&#x2F;openqa&#x2F;selenium&#x2F;firefox&#x2F;目录下）</p>
<p>new FirefoxDriver()时，启动Firefox浏览器时，带此插件一起启动，然后插件会默认监听7055端口，7055被占用就使用下一个端口。如下图所示。<br><img src="http://image.windanchaos.tech/blog/dn.net-20160424100800878.png" alt="这里写图片描述"><br>同一台机器上可以同时启动多个FirefoxDriver实例，每个实例占用不同的端口号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">The</span> <span class="title class_">WebDriver</span> <span class="title class_">Wire</span> <span class="title class_">Protocol</span> 协议的具体内容请看：<span class="attr">https</span>:<span class="comment">//code.google.com/p/selenium/wiki/JsonWireProtocol#Introduction。  这个协议现在正在被W3C标准化，W3C Webdriver，两者基本一样。  </span></span><br><span class="line"><span class="variable constant_">W3C</span> <span class="title class_">Webdriver</span>标准协议内容：<span class="attr">http</span>:<span class="comment">//www.w3.org/TR/webdriver/</span></span><br></pre></td></tr></table></figure>

<p>（2）WebdriverServer接收到Http Request之后，根据不同的命令在<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/operatingsystem" title="操作系统知识库">操作系统</a>层面去触发浏览器的”native事件“，<br>模拟操作浏览器。WebdriverServer将操作结果Http Response返回给代码调用的客户端。</p>
<p>为了更清晰直观地看到这个是如何运转的，我们来在使用OWASP ZAP做代理，截获Http Request和Response来看一下。<br>首先安装OWASP ZAP或其他有代理功能的工具，设置SoapUI Proxy，如ZAP默认使用8080端口，则SoapUI配置如下：<br><img src="http://image.windanchaos.tech/blog/dn.net-20160424100954806.png" alt="这里写图片描述"><br>配置完SoapUI端口后，好像需要重启SoapUI，然后在SoapUI 的自动化测试代码中，代理才能正常工作。</p>
<p>重新跑前一节FirefoxDriver的代码，查看截获的请求和响应。如下图所示：<br><img src="http://image.windanchaos.tech/blog/dn.net-20160424101223635.png" alt="这里写图片描述"></p></div><p class="readmore"><a href="/2017/04/17/Selenium%20Webdriver%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E4%BE%8B/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/17/Appium%20%E5%BE%AE%E4%BF%A1%20webview%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/">Appium 微信 webview 的自动化技术</a></h1><div class="post-meta">2017-04-17</div><div class="post-content">目录 
1&lt;blockquote&gt;

最近好多人问微信webview自动化的事情, 碰巧我也在追微信webview的自动化和性能分析方法.先发出来一点我的进展给大家参考下. 此方法用于android平台, iOS请自行解决
微信的设置用微信打开debugx5.qq.com, 这是个微信的x5内核调试页面. 你可以在任何聊天窗口内输入这个网址. 并...</div><p class="readmore"><a href="/2017/04/17/Appium%20%E5%BE%AE%E4%BF%A1%20webview%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/13/Selenium%202.0%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">Selenium 2.0的由来及设计架构</a></h1><div class="post-meta">2017-04-13</div><div class="post-content"><p>本文转自：blog.csdn.net&#x2F;zzzmmmkkk&#x2F;article&#x2F;details&#x2F;10034213</p>
<p><strong>布局和<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javascript" title="JavaScript知识库">JavaScript</a></strong></p>
<p>浏览器自动化工具基本上由三部分构成：</p>
<p>·与DOM交互的方法</p>
<p>·执行Javascript的机制</p>
<p>·一些模拟用户输入的办法</p>
<p>本节重点介绍第一部分：提供与DOM交互的机制。浏览器的办法是通过Javascript，所以看起来与DOM交互的理想语言也是它。虽然这种选择似乎显而易见，但是在考虑Javascript时需要平衡一些有趣的挑战和需求。</p>
<p>像多数大型项目一样，Selenium使用了分层的库结构。底层是Google的Closure库，提供原语和模块化机制来协助源文件保持精简。在此之上，有一个实用工具库，提供的函数包括简单的任务，如获取某个属性值、判断某个元素是否对用户可见，还包括更加复杂的操作，如通过合成事件模拟用户点击。在项目中，这些被视为提供最小单元的浏览器自动化，因此称之为浏览器自动化原子（Browser Automation Atom）。最后，还有适配层来组合这些原子单元以满足WebDriver和Core的API协议。</p>
<p><img src="http://image.windanchaos.tech/blog/dn.net-20130817205048703-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenp6bW1ta2tr-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<p>图 3：Selenium Javascript库的层次结构</p>
<p>选择Closure库基于几种原因。主要理由是Closure编译器理解库使用的模块化技术。Closure编译器的目标是输出Javascript。“编译”可以简单到按照依赖顺序查找输入文件、串联并漂亮的打印出来，也可能复杂到进行精细的改动和删除死代码。另一种不可否认的优势是团队中采用Javascript编程的几位成员对Closure库非常熟悉。</p>
<p>当需要与DOM交互时，“原子”库的代码会被用于项目中的各个角落。对于RC和那些大部分由Javascript编写而成的driver来说，这些库被直接使用，通常编译为单个巨大的脚本。对于采用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase" title="Java SE知识库">Java</a>编写的driver，来自WebDriver适配层的各个函数在编译的时候会启用完整优化，生成的Javascript在JAR中作为资源包含进来。对于采用C语言编写的driver，如iPhone IE驱动，不仅各个函数被通过完整优化来编译，而且生成的输出文件被转换成定义在头文件中的常量，通过driver的正常Javascript执行机制来执行。虽然这看起来有些奇怪，但是这种做法使Javascript放在底层驱动中，无须在各处暴露原始的代码。</p>
<p>因为原子库应用广泛，所以在不同浏览器之间确保一致的行为是可行的，因为库采用Javascript编写，而且无需提升权限来执行开发周期，所以方便、快捷。Closure库可以动态加载依赖，因此Selenium开发人员只需编写<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>并在浏览器中加载，修改代码并在需要时点击刷新按钮。一旦测试在浏览器中通过，很容易在另一个浏览器中加载并确保通过。因为Closure库在抽象屏蔽浏览器之间的差异方面做得很好，这就足够在持续构建中在每一种支持的浏览器中运行测试集以衡量是否通过。</p>
<p>最初Core和WebDriver存在许多相同的代码——通过略微不同的方式执行相同的功能。当我们开始关注原子库时，这些代码被重新梳理，我们努力找出最合适的功能。毕竟，两个项目都被广泛应用，它们的代码非常健壮，因此把一切都丢掉从零开始不仅浪费而且愚蠢。通过对每个原子库的分析，我们找出了可以使用的部分。例如，Firefox driver的getAttribute方法从大约50行缩减到几行，包括空白行在内：</p>
<p>FirefoxDriver.prototype.getElementAttribute &#x3D;function(respond, parameters) {var element &#x3D; Utils.getElementAt(parameters.id, respond.session.getDocument());var attributeName &#x3D; parameters.name;respond.value &#x3D; webdriver.element.getAttribute(element, attributeName);respond.send();};</p>
<p>倒数第二行中，respond.value的赋值调用了原子级的WebDriver库。</p>
<p>原子库是本项目若干<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/architecture" title="大型网站架构知识库">架构</a>思想的实际演示。当然，它们满足了API的实现应该倾向于Javascript的需求。更出色的是，用一个库在代码库中分享，以前一个缺陷需要在多种实现中验证和修复，现在只需在一个地方修改即可，这种做法降低了变化的成本，同时提高了稳定性和有效性。原子库也使项目的“巴士”因素更优化。因为通常的Javascript单元测试可以用于验证缺陷是否修复，所以参与到开源项目中的障碍要比之前需要了解每一个driver如何实现的时候更低。</p>
<p>使用原子库还有另外一个好处。模拟现有RC实现但由WebDriver支持的分层对团队尝试以可控的方式迁移到更新的WebDriver API是一种重要的工具。因为Selenium Core是原子化的，所以单独编译每一个函数是可行的，使得编写这种模拟层易于实现而且更准确。</p>
<p>当然，这种做法也存在缺点。最重要的是，把Javascript编译成C常量是一种非常奇怪的事情，它总是阻碍那些想参与C语言编程的项目贡献者。而且很少有开发人员能够了解所有浏览器并致力于每一种浏览器上运行所有测试——很可能有人会不小心在某处引入回归问题，我们需要花时间找到问题，如果持续构建很多的话则更需精力。</p></div><p class="readmore"><a href="/2017/04/13/Selenium%202.0%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/13/Selenium%201.0%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Selenium 1.0的历史及工作原理</a></h1><div class="post-meta">2017-04-13</div><div class="post-content"><p>本文引至：<a target="_blank" rel="noopener" href="http://blog.csdn.net/zzzmmmkkk/article/details/9274781">http://blog.csdn.net/zzzmmmkkk/article/details/9274781</a></p>
<p>当你看到这篇文章时一定会诧异，2.0都广泛使用了，为何还要了解1.0的内容呢？1.0的确已经慢慢的成为历史，那我们就先通过历史来认识一下selenium的发展吧。</p>
<p>Jason Huggins在2004年发起了Selenium项目，当时他在ThoughtWorks公司开发内部的时间和费用（Time and Expenses）系统，该应用使用了大量的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javascript" title="JavaScript知识库">JavaScript</a>。虽然IE在当时是主流浏览器，但是ThoughtWorks还使用一些其他浏览器（特别是Mozilla系列），当员工在自己的浏览器中无法正常运行T&amp;E系统时就会提交bug。当时的开源工具要么关注单一浏览器（通常是IE），要么是模拟浏览器（如HttpUnit），而购买商业工具授权的成本会耗尽这个小型内部项目的有限预算，所以它们都不太可行。</p>
<p>幸运的是，所有被<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库">测试</a>的浏览器都支持Javascript。Jason和他所在的团队有理由采用Javascript编写一种测试工具来验证应用的行为。他们受到FIT(Framework for Integrated Test）的启发，使用基于表格的语法替代了原始的Javascript，这种做法支持那些编程经验有限的人在HTML文件中使用关键字驱动的方式来编写测试。该工具，最初称为“Selenium”，后来称为“Selenium Core”，在2004年基于Apache 2授权发布。</p>
<p>Selenium的表格格式类似于FIT的ActionFixture。表格的每一行分为三列。第一列给出了要执行的命令名称，第二列通常包含元素标记符，第三列包含一个可选值。例如，如下格式表示了如何在名称为“q”的元素中输入字符串“Selenium”：</p>
<p>type name&#x3D;q Selenium</p>
<p>因为Selenium过去使用纯JavaScript编写，它的最初设计要求开发人员把准备测试的应用和Selenium Core、测试脚本部署到同一台服务器上以避免触犯浏览器的安全规则和JavaScript沙箱策略。在实际开发中，这种要求并不总是可行。更糟的是，虽然开发人员的IDE能够帮助他们快速处理代码和浏览庞大的代码库，但是没有针对HTML的相关工具。人们很快意识到维护一个中等规模的测试集是笨拙而痛苦的过程。</p>
<p>为了解决这个问题和其他问题，他们编写了HTTP代理，这样所有的HTTP请求都会被Selenium截获。使用代理可以绕过“同源”规则（浏览器不支持Javascript调用任何当前页面所在服务器以外的其他任何东西）的许多限制，从而缓解了首要弱点。这种设计使得采用多种语言编写Selenium成为可能：它们只需把HTTP请求发送到特定URL。连接方法基于Selenium Core的表格语法严格建模，称之为“Selenese”。因为语言绑定在远程控制浏览器，所以该工具称为“Selenium Remote Control”或者“Selenium RC”。</p>
<p>就在Selenium处于开发阶段的同时，另一款浏览</p>
<p>器自动化框架WebDriver也正在ThoughtWorks公司的酝酿之中。Selenium2.0之webdriver的介绍请期待下一篇文章。</p>
<p>上面介绍中其实也提到了1.0的概况，下图就是它的流程。</p>
<p><img src="http://image.windanchaos.tech/blog/dn.net-20140227220501421-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenp6bW1ta2tr-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<ol>
<li><p>测试用例通过Http请求建立与 selenium-RC server 的连接</p>
</li>
<li><p>Selenium RC Server 驱动一个浏览器，把Selenium Core加载入浏览器页面当中，并把浏览器的代理设置为Selenium Server的Http Proxy</p>
</li>
<li><p>执行用例向Selenium Server发送Http请求，Selenium Server对请求进行解析，然后通过Http Proxy发送JS命令通知Selenium Core执行操作浏览器的动作并注入 JS 代码</p>
</li>
</ol>
<p>4.Selenium Core执行接受到的指令并操作</p>
<ol start="5">
<li><p>当浏览器收到新的请求时，发送http请求</p>
</li>
<li><p>Selenium Server接收到浏览器发送的Http请求后，自己重组Http请求，获取对应的页面</p>
</li>
<li><p>Selenium Server中的Http Proxy把接受到的页面返回给浏览器。</p></div><p class="readmore"><a href="/2017/04/13/Selenium%201.0%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/09/python%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/">python爬取百度图片</a></h1><div class="post-meta">2017-04-09</div><div class="post-content">爬虫的原理：读取页面html元素，解析出目标的url，进入或下载保存。一开始想从百度搜索的结果页面中爬点图片当素材，看了几个前辈写的，很多思路。比如：http://blog.csdn.net/seanwang_25&#x2F;article&#x2F;details&#x2F;43318907
最终实验，目前百度图片搜索列表的元素识别我没有搞定，最后的思路还...</div><p class="readmore"><a href="/2017/04/09/python%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/14/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%88%9D%E6%8E%A2%E4%B8%80/">股票量化交易初探一</a></h1><div class="post-meta">2017-03-14</div><div class="post-content">最近学习自动化，摆平了后台发布商品的功能回归测试，基本达到目的。本打算深入下去，多完成高频的回归测试case的，不过鉴于都是元素获取及流程方面的，无法精进技术，作罢。转移注意力到股票交易上来，一来自己一直有一个幻想（如能实现便说是梦想），可以用程序提高交易的成功率，二来通过实现的过程，挖坑爬坑，技术会得到提升。本研究的主要目标：基于python实现，跑通主要...</div><p class="readmore"><a href="/2017/03/14/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%88%9D%E6%8E%A2%E4%B8%80/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/02/23/web%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/">web测试中的特殊字符</a></h1><div class="post-meta">2017-02-23</div><div class="post-content">JavaScript 特殊字符需要被转义才能显示正确，转义是斜线。\’ 单引号\” 双引号&amp; 和号\ 反斜杠\n 换行符\r 回车符\t 制表符\b 退格符\f 换页符
HTML需要转义的字符转义对照表
数据库特殊字符：_ (下划线) : Oracle中代表占位符表示查找含_的字符串。%（百分号）表示查找含%的字符串。‘(单引号)：表示查找含’的字符...</div><p class="readmore"><a href="/2017/02/23/web%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/02/17/Splinter%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/">Splinter使用中遇到的问题集锦</a></h1><div class="post-meta">2017-02-17</div><div class="post-content"><h1 id="已经解决"><a href="#已经解决" class="headerlink" title="已经解决"></a>已经解决</h1><p>1、selenium.common.exceptions.ElementNotVisibleException: Message: element not visible<br>2、selenium.common.exceptions.InvalidElementStateException: Message: invalid element state: Element is not currently interactable and may not be manipulated<br>出现以上两种异常的原理：<br>1、元素还没加载出来就操作，通常是alert框，解决办法time.sleep(1)，时间自己调试。<br>2、元素你看得到，但是代码要操作的元素是跟随鼠标变更样式的，或者其他条件实时变更的，导致代码不能“看见”。这种情况就需要通过js操作dom元素来适应场景。<br>我测试页面有一个input，在鼠标不操作是时候样式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;batch_quto&quot;</span> value=<span class="string">&quot;0&quot;</span> data-role=<span class="string">&quot;numerictextbox&quot;</span> role=<span class="string">&quot;spinbutton&quot;</span> style=<span class="string">&quot;display: none;&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;k-input&quot;</span> type=<span class="string">&quot;text&quot;</span> aria-valuemin=<span class="string">&quot;0&quot;</span> aria-valuenow=<span class="string">&quot;0&quot;</span> aria-disabled=<span class="string">&quot;false&quot;</span> aria-readonly=<span class="string">&quot;false&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当鼠标点击输入框，样式变为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;batch_quto&quot;</span> value=<span class="string">&quot;0&quot;</span> data-role=<span class="string">&quot;numerictextbox&quot;</span> role=<span class="string">&quot;spinbutton&quot;</span> style=<span class="string">&quot;display: inline-block;&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;k-input&quot;</span> type=<span class="string">&quot;text&quot;</span> aria-valuemin=<span class="string">&quot;0&quot;</span> aria-valuenow=<span class="string">&quot;0&quot;</span> aria-disabled=<span class="string">&quot;false&quot;</span> aria-readonly=<span class="string">&quot;false&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>二者的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style=<span class="string">&quot;display: none;&quot;</span></span><br><span class="line">style=<span class="string">&quot;display: inline-block;&quot;</span></span><br></pre></td></tr></table></figure>

<p>display 属性设置元素如何显示。所以无论是通过xpath、id来定位元素都无法用代码输入文本到input。<br>解决方法，使用splinter的js执行方法操作该input 的style属性，而要在你操作的若干个div嵌套中发现你操作的元素才是真正的难点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 以下<span class="number">4</span>行代码耗费我<span class="number">3</span>天的时间实验验证得出</span><br><span class="line">browser.evaluate_script(<span class="string">&#x27;document.getElementById(&quot;batch_quto&quot;).style=&quot;display: inline-block; visibility: visible;&quot;&#x27;</span>)</span><br><span class="line">browser.evaluate_script(<span class="string">&#x27;document.getElementById(&quot;batch_quto&quot;).contentEditable = true&#x27;</span>)</span><br><span class="line">browser.<span class="title function_">find_by_id</span>(<span class="string">&#x27;batch_quto&#x27;</span>).<span class="title function_">fill</span>(<span class="string">&quot;120&quot;</span>)</span><br><span class="line"># 还原样式以免影响其他显示</span><br><span class="line">browser.evaluate_script(<span class="string">&#x27;document.getElementById(&quot;batch_quto&quot;).style=&quot;display: none; visibility: visible;&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2017/02/17/Splinter%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/02/12/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/">HTML、CSS基础</a></h1><div class="post-meta">2017-02-12</div><div class="post-content"><p>本文是使用splinter过程中，遇到阻碍（主要是动态样式导致element not visiable）,而推演出来的基础学习内容。以下内容早在2013年左右就看过，全当复习总结重新来一次，所以html常用的如标题、段落、链接、图像、表格等没有列入。本问内容全部来自：<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/">http://www.w3school.com.cn</a> 感谢无私的网站提供的基础学习内容。</p>
<h1 id="HTML基础概念"><a href="#HTML基础概念" class="headerlink" title="HTML基础概念"></a>HTML基础概念</h1><p>什么是 HTML？</p>
<p>HTML 是用来描述网页的一种语言。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTML</span> 指的是超文本标记语言 (<span class="title class_">Hyper</span> <span class="title class_">Text</span> <span class="title class_">Markup</span> <span class="title class_">Language</span>)</span><br><span class="line"><span class="variable constant_">HTML</span> 不是一种编程语言，而是一种标记语言 (markup language)</span><br><span class="line">标记语言是一套标记标签 (markup tag)</span><br><span class="line"><span class="variable constant_">HTML</span> 使用标记标签来描述网页</span><br></pre></td></tr></table></figure>

<p>HTML 标签</p>
<p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTML</span> 标签是由尖括号包围的关键词，比如 &lt;html&gt;</span><br><span class="line"><span class="variable constant_">HTML</span> 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;</span><br><span class="line">标签对中的第一个标签是开始标签，第二个标签是结束标签</span><br><span class="line">开始和结束标签也被称为开放标签和闭合标签</span><br></pre></td></tr></table></figure>

<p>所有标签：<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/tags/index.asp">http://www.w3school.com.cn/tags/index.asp</a></p>
<p>HTML 文档 &#x3D; 网页</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTML</span> 文档描述网页</span><br><span class="line"><span class="variable constant_">HTML</span> 文档包含 <span class="variable constant_">HTML</span> 标签和纯文本</span><br><span class="line"><span class="variable constant_">HTML</span> 文档也被称为网页</span><br></pre></td></tr></table></figure>

<p>HTML 元素</p>
<p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。<br>开始标签 元素内容 结束标签</p></div><p class="readmore"><a href="/2017/02/12/HTML%E3%80%81CSS%E5%9F%BA%E7%A1%80/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/02/09/selenium%E3%80%81splinter%E6%9F%A5%E6%89%BE%E6%93%8D%E6%8E%A7%E5%85%83%E7%B4%A0%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F/">selenium、splinter查找操控元素的杀手锏</a></h1><div class="post-meta">2017-02-09</div><div class="post-content">1、使用xpath使用splinter中无法获取到弹出框的元素，因为后台使用的div做的弹出框（看起来是javascript+css做出来的，不是浏览器原生的alert）。无意中发现chrome浏览器可以拷贝元素的xpath，于是就搞定了。方法如图：选中元素，在开发者工具中的elements下会有选中区域，右键即可。
接着使用：
1browser.is_el...</div><p class="readmore"><a href="/2017/02/09/selenium%E3%80%81splinter%E6%9F%A5%E6%89%BE%E6%93%8D%E6%8E%A7%E5%85%83%E7%B4%A0%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://windanchaos.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/images/avatar.jpeg"/></a><p>物有本末，事有终始。知所先后，则近道矣！</p><a class="info-icon" href="https://blog.csdn.net/windanchaos" title="CSDN" target="_blank" style="margin-inline:5px"> <i class="fa fa-CSDN-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:454522630@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/windanchaos" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://gitee.com/windanchaos" title="Gitee" target="_blank" style="margin-inline:5px"> <i class="fa fa-gitee-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">Java编程语言</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/">Linux管理维护</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">MySQL数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">python编程语言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">前端框架和技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">后端框架和技术</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%B9%E6%B3%95%E4%B8%8E%E7%AE%A1%E7%90%86/">方法与管理</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E6%8A%80%E6%9C%AF/">测试的框架和技术</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E5%A4%A7%E6%9D%82%E7%83%A9/">生活大杂烩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%82%A1%E7%A5%A8%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">股票量化交易</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/">计算机科学基础</a><span class="category-list-count">16</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/FromCSDN/" style="font-size: 15px;">FromCSDN</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a> <a href="/tags/testerhome/" style="font-size: 15px;">testerhome</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/%E3%80%908-%E4%BD%8D-CPU%E3%80%91%E6%94%92%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%AE%A1%E7%AE%97%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E5%88%9D%E4%BB%A3-CPU/">【8 位 CPU】攒个可以计算加减法的初代 CPU</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/22/%E3%80%908-%E4%BD%8D-CPU%E3%80%91%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%BB%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8/">【8 位 CPU】一步一步画个寄存器</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/17/%E3%80%908-%E4%BD%8D-CPU%E3%80%918-%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8/">【8 位 CPU】8 位加法器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BARAM%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">计算机RAM的底层原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/24/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%B8%AA%E6%AD%BB%E5%BE%AA%E7%8E%AF/">内核启动过程 -- 操作系统是个死循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E5%B1%82%E6%AC%A1%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6/">计算机各层次执行速度</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/JDK%E4%B8%ADJUC%E5%8C%85%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94atomic%E5%8C%85/">JDK中JUC包由浅入深原理——atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/22/ELF%E5%AD%A6%E4%B9%A0%E4%B8%80/">ELF学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/07/SpringBoot%E4%B9%8B%E5%8D%9A%E5%AE%A2%E5%AE%9E%E6%88%98/">SpringBoot之博客实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/17/shell%E4%B8%89%E5%89%91%E5%AE%A2%E5%AE%9E%E6%88%98/">shell三剑客实战</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">windanchaos.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>